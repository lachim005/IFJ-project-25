\documentclass[a4paper]{article}

\usepackage[text={18.6cm, 26.0cm}, centering]{geometry}

\usepackage[czech, provide=*]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{color}
\usepackage{graphicx}
\usepackage{alltt} % \verb
\usepackage[]{hyperref} % odkazy
\usepackage{tikz}

\input{tabulky}
% Ceske uvozovky
\providecommand{\uv}[1]{\quotedblbase #1\textquotedblleft}

\begin{document}
    \begin{titlepage}
        \begin{center}
            \textsc{\Huge{}Vysoké učení technické v Brně\\[0.5em]}
            \textsc{\huge Fakulta informačních technologií}\\
            \vspace{\stretch{0.382}}
            { \huge Wren překladač\,--\,dokumentace\\[0.5em]
                IFJ/IAL 2025 }\\[0.5em]
                Tým xsebesm00, varianta TRP-izp\\
            \vspace{\stretch{0.618}}
        \end{center}
        { \phantom{a}\hfill FUNEXP\\
          \phantom{a}\hfill EXTSTAT\\
          Vojtěch Borýsek (xborysv00)\,--\, 33\% \hfill EXTFUN\\
          Šimon Halas (xhalass00)\,--\, 00\% \hfill BOOLTHEN\\
          Tomáš Hanák (xhanakt00)\,--\, 33\% \hfill OPERATORS\\
          Michal Šebesta (xsebesm00)\,--\, 34\%, vedoucí \hfill STATICAN\\
          }
    \end{titlepage}
    \tableofcontents
    \newpage
    \section{Přehled}
        \begin{figure}[ht]
            \centering
            \begin{tikzpicture}[
                    every node/.style={fill=white},
                    block/.style={rectangle, draw=yellow, fill=yellow!5, very thick, minimum size=15mm, inner sep=4pt,draw},
                    node distance=3cm,
                    align=center,
                ]
                \node[block] (lexer) {Lexikální analyzátor\\ \texttt{lexer.c}};
                \node[block] (parser) [below of=lexer] {Syntaktický analyzátor\\ \texttt{parser.c}};
                \node[block] (expr) [right of=parser, xshift=4cm]{Precedenční analyzátor\\ \texttt{expr\_parser.c}};
                \node[block] (optimizer) [below of=parser] {Optimalizátor\\ \texttt{optimizer.c}};
                \node[block] (codegen) [below of=optimizer] {Generátor kódu\\ \texttt{code\_generator.c}};

                \draw[->] (lexer.south) -- node {Tokeny} (parser.north);
                \draw[->] (expr.west) -- node {ASS výrazu} (parser.east);
                \draw[->] (parser.south) -- node {ASS programu} (optimizer.north);
                \draw[->] (optimizer.south) -- node {Optimalizovaný ASS programu} (codegen.north);
            \end{tikzpicture}
            \caption{Diagram komponent překladače}
            \label{fig:compiler-diagram}
        \end{figure}
        Překlad začíná inicializací lexikálního analyzátoru. Ten je následně předán syntaktickému analyzátoru,
        který jej volá v případě potřeby tokenu. Pokud syntaktický analyzátor potřebuje načíst výraz, volá precedenční
        analyzátor. V rámci syntaktického analyzátoru se rovnou také provádí sémantické akce,
        jako kontrola typů ve výrazech, nebo kontrola deklarace proměnných. Výsledek ukládá do abstraktního
        syntaktického stromu (ASS).

        Jakmile je celý program převeden na ASS a sémanticky zkontrolován, je tento strom předán do optimalizátoru.
        Optimalizovaný strom je následně předán generátoru kódu, který z něj vytvoří cílový kód, čímž překlad končí.


    \section{Lexikální analýza}
        Lexikální analyzátor čte vstupní program a rozděluje ho na jednotlivé tokeny. Je volán syntaktickým analyzátorem,
        kontkrétně metodou \texttt{lexer\_get\_token()}. K dispozici je také funkce \texttt{lexer\_unget\_token()}, která
        syntaktickému analyzátoru umožňuje token vrátit a načíst ho později, což se hodí v situacích,
        kde další pravidlo není jasné a může být potřeba token vrátit jiné proceduře.

        Nové řádky se berou jako token, a jejich správné umístění řeší syntaktická analýza.

        Lexikální analyzátor také přijímá tokeny pro zadání rozsahu do příkazu \texttt{for}, ale
        celé rozšíření nakonec implementováno nebylo.

        Lexikální analyzátor je implementován jako konečný stavový automat (\ref{app:fsm}). Většinu typů tokenů jsme schopni
        pokrýt pouze automatem. U některých typů ale musíme vyzužít něco navíc. Lexikální analyzátor má k
        dispozici dva znakové buffery a jeden čítač, které využívá k načtení následujících typů tokenů.

        \subsection{Číselné literály}
            V momentě kdy automat přejde do stavu, kde se začíná zpracovávat číselný literál, začne
            vstupní znaky psát do \texttt{buf1}. Jakmile narazíme na konec literálu, výsledný řetězec je
            převeden na \texttt{double} pomocí funkce \texttt{strtod()} nebo \texttt{hex2int()}.

        \subsection{Řetězcové literály}
            Klasické řetězcové literály se zapisují do \texttt{buf1} a výsledek je na konci vrácen uvnitř
            tokenu.

            Víceřádkové řetězcové literály jsou složitější. Znaky se nejprve čtou do \texttt{buf2}
            dokud se nenarazí na znak nového řádku. V ten moment se obsah \texttt{buf2} přidá na konec
            \texttt{buf1}, pokud řádek v \texttt{buf2} není první nebo poslední. Pokud je, do
            \texttt{buf1} se nepřidá jestliže je prázdný nebo obsahuje pouze bílé znaky.
        \subsection{Víceřádkové komentáře}
            Víceřádkové komentáře mohou být zanořeny, takže lexikální analyzátor potřebuje čítač
            zanoření. Při uzavření víceřádkového komentáře se podle stavu čítače přejde do stavu
            uvnitř komentáře nebo mimo komentář.

        \subsection{Identifikátory a klíčová slova}
            Automat nijak nerozlišuje klíčová slova. Z jeho pohledu načte identifikátor, který
            čte do \texttt{buf1}. Než je token identifikátoru vrácen, lexikální analyzátor se
            podívá do tabulky klíčových slov a pokud v ní načtený text najde, vrátí místo tokenu
            identifikátoru token správného klíčového slova.


    \section{Syntaktický analýza}
        Syntaktická analýza je implementována metodou rekurzivního sestupu podle LL gramatiky (\ref{app:llgram}, \ref{app:lltable}).
        Hlavní program volá funkci \texttt{parse()}, která je vstupním bodem celé analýzy. 
        Tato funkce inicializuje globální tabulku symbolů, přidá do ní vestavěné funkce a následně postupně volá funkce pro kontrolu jednotlivých částí programu.

        Parser získává tokeny od lexikálního analyzátoru pomocí funkce \texttt{lexer\_get\_token()}.
        Pokud narazí na výraz, volá precedenční analyzátor funkcí \texttt{parse\_expression()}, která zpracuje výraz a vrátí uzel ASS reprezentující tento výraz.
        Syntaktická analýza zároveň provádí sémantické kontroly, které ověřují správnost typů, existenci proměnných a funkcí, a detekují redefinice.
        
        Pro každou funkci, getter a setter se během analýzy vytváří nová lokální tabulka symbolů, která je následně uložena v ASS v příslušném uzlu.
        Tato tabulka obsahuje lokální proměnné a parametry dané funkce či getteru/setteru.
        
        Jestliže nelze v těle bloku použít žádné pravidlo pro načtení příkazu, vrátí se všechny zatím načtené tokeny a zavolá se
        precedenční analyzátor. Ten zpracuje samovolně stojící výraz, který se vyhodnotí a jeho hodnota se následně zahodí. Tento
        přístup pokryje i samovolně stojící funkce (Rozšíření \texttt{EXTFUN}).

        Výsledkem syntaktické analýzy je ASS reprezentující celý program a globální tabulka symbolů obsahující všechny globální proměnné a funkce.
    \subsection{Tabulka symbolů}
        Tabulka symbolů slouží k ukládání informací o proměnných, funkcích, getterech a setterech v průběhu překladu. 
        Je implementována jako hash tabulka s implicitním zřetězením položek (otevřené adresování metodou lineárního přidávání). Pro výpočet hash hodnoty je použit algoritmus djb2\footnote{\url{http://www.cse.yorku.ca/~oz/hash.html}}, který je rychlý, efektivní a poskytuje dobrou distribuci hash hodnot pro řetězce.

        Každá položka tabulky obsahuje klíč, název symbolu, typ symbolu (\texttt{SYM\_GLOBAL\_VAR}, \texttt{SYM\_FUNCTION}, \texttt{SYM\_GETTER}, \texttt{SYM\_SETTER}, \texttt{SYM\_VAR}), datový typ, počet parametrů u funkcí, pole typů parametrů, příznak definice a případně známou hodnotu při překladu.

        Tabulka dynamicky roste při dosažení 70\% zaplnění na dvojnásobnou kapacitu. Místo skutečného mazání se položky pouze označí příznakem jako smazané, což umožňuje korektní fungování lineárního přidávání a tyto sloty mohou být při vkládání nových prvků znovu využity.

        Pro správu viditelnosti proměnných v různých rozsazích slouží zásobník rozsahů. Každý vstup do bloku přidá na zásobník nový unikátní identifikátor rozsahu, při výstupu se odstraní. 
        Lokální proměnné mají v tabulce klíč ve formátu \texttt{název?scope\_id}, funkce \texttt{název\$počet\_parametrů}, gettery \texttt{název!}, settery \texttt{název*} a globální proměnné pouze \texttt{název}.
        Při hledání lokální proměnné se prochází zásobník rozsahů od nejvnitřnějšího po nejvyšší, dokud není proměnná nalezena.

        Pro usnadnění práce s tabulkou jsou k dispozici pomocné funkce pro operace s různými typy symbolů, které automaticky zajišťují správný formát klíčů.
    \subsection{Sémantická analýza}
        Sémantická analýza probíhá současně se syntaktickou analýzou během rekurzivního sestupu.
        Kontroluje se existence a správné použití proměnných, funkcí, getterů a setterů v rámci jejich platných rozsahů.
        Při deklaraci nových symbolů se ověřuje, zda nedochází k redefinici již existujících symbolů.

        Typová kontrola výrazů probíhá pomocí funkce \texttt{semantic\_check\_expression()}, která rekurzivně prochází strukturu \texttt{AstExpression} získanou od precedenční analýzy.
        Funkce ověřuje, zda typy operandů odpovídají požadavkům operátorů a zda jsou všechny použité symboly korektně definovány.
        Po dokončení analýzy se také kontroluje, zda byly všechny použité symboly definovány a zda existuje funkce \texttt{main} s nula parametry, která slouží jako vstupní bod programu.
    \subsection{Zpracování výrazů}
        Výrazy jsou v překladači zpracovávány pomocí syntaktické analýzy zdola nahoru. 
        Přesněji je využit precedenční syntaktický analyzátor, který výraz zpracovává pomocí práce s precedencní tabulkou (\ref{app:prectable}).

        Tato analýza je volána pomocí funkce \texttt{parse\_expression()} z hlavního syntaktického analyzátoru. 
        
        Podle nejvyššího terminálu na zásobníku a nyní přečtenému tokenu rozhoduje, zdali provede shift na zásobník (<) nebo výraz zredukuje (>). 
        Při redukci je rozhodnuto, zda se jedná o unární, binární nebo ternární operátor a podle tohoto se poté celé pravidlo zredukuje a vytvoří se token E, který si uloží uzel ASS pro výraz do své hodnoty. 
        Tato redukce probíhá pomocí volání funkce \texttt{stack\_is\_sequence\_on\_top()}, která zkontroluje, jestli se na vrcholu zásobníku nachází předpokládané pravidlo. 
        Pokud ne, jedná se o syntaktickou chybu, vrací se správný návratový kód a analýza se přerusí. 
        
        Speciální prípad nastává u funkcí, kdy se analyzátor prvně podívá, co následuje za identifikátorem, pokud se jedná o '(', pak zavolá funkci \texttt{reduce\_function\_call()}. 
        Zpracovávány jsou rovněž builtin funkce, pro které je volána funkce \texttt{reduce\_buildtin\_call()}. 
        
        Anaýza se ukončuje při naražení na nepárovou uzavírací závorku, čárku, nebo nevhodně umístěný znak nového řádku. V tom případě se poslední načtený token
        vrátí pomocí \texttt{lexer\_unget\_token()}. Po skončení zpracování výrazu je následně volajícímu vrácen otcovský uzel celého tohoto výrazu. 
    \subsection{Abstraktní syntaktický strom}
        ASS slouží k reprezentaci struktury programu v překladači. Skládá se z uzlů reprezentujících příkazy a výrazy. 
        Každý uzel příkazu obsahuje typ příkazu (\texttt{AstStatementType}) a union, který uchovává specifická data pro daný typ příkazu.

        Union umožňuje efektivní využití paměti\,--\,každý uzel zabírá pouze tolik místa, kolik potřebuje největší typ příkazu. 
        Možné typy příkazů zahrnují bloky, podmínky, cykly, deklarace proměnných, definice funkcí, getterů, setterů, návratové příkazy a samostatné výrazy.

        Příkazy jsou organizovány do spojového seznamu pomocí ukazatele \texttt{next}, což umožňuje iteraci přes sekvenci příkazů. Bloky obsahují ukazatel na první příkaz v bloku, z něhož lze projít celý řetězec příkazů.

        Výrazy jsou reprezentovány stromovou strukturou, kde každý uzel obsahuje typ výrazu (\texttt{AstExprType}), pole podvýrazů a informace o datovém typu a případné známé hodnotě z optimalizace. 
        Tímto způsobem překladač ukládá celý zdrojový kód do ASS, který je následně předán optimalizátoru a generátoru kódu.

    \section{Optimalizátor}
        Optimalizátor provádí optimalizaci abstraktního syntaktického stromu před jeho předáním generátoru kódu.
        Prochází celý ASS rekurzivně a vyhodnocuje výrazy, které lze vypočítat již v době překladu, čímž
        snižuje složitost výsledného kódu a zvyšuje rychlost běhu programu. Vstupním bodem je funkce \texttt{optimize\_ast()}.

        \subsection{Vyhodnocování konstantních výrazů}
        Optimalizátor vyhodnocuje výrazy, jejichž všechny operandy jsou známé v době překladu.
        Příklad aritmetické operace:
        \begin{alltt}
2 + 3  \(\rightarrow\)  5
        \end{alltt}

        \subsection{Vyhodnocování vestavěných funkcí}
        Optimalizátor dokáže vyhodnotit volání vestavěných funkcí s konstantními parametry.
        Příklad:
        \begin{alltt}
Ifj.length("hello")  \(\rightarrow\)  5.0
        \end{alltt}

        \subsection{Propagace konstant}
        Optimalizátor sleduje hodnoty proměnných a využívá je k další optimalizaci. 
        Pokud je hodnota proměnné známá, nahradí její použití přímo hodnotou:
        \begin{alltt}
var x = 5
var y = x + 3    // x je známé \(\rightarrow\) y = 5 + 3 \(\rightarrow\) y = 8
var z = y * 2    // y je známé \(\rightarrow\) z = 8 * 2 \(\rightarrow\) z = 16
        \end{alltt}

        \subsection{Ošetření vedlejších efektů}
        Optimalizátor musí správně zacházet s operacemi, které mohou mít vedlejší efekty.
        Při volání funkcí, getterů a setterů se maží všechny známé hodnoty globálních proměnných,
        protože tyto operace mohou proměnné modifikovat. V podmínkách a cyklech se rovněž maží
        známé hodnoty, protože není jisté, která větev se vykoná nebo kolikrát se cyklus opakuje.

    \section{Generátor kódu}
        Generátor kódu přijímá ASS a generuje z něj cílový program v IFJcode25. Vstupní metoda generátoru
        je \texttt{generate\_code()}. Generování následně probíhá následovně:
        \begin{enumerate}
            \item Podle globální tabulky symbolů se vygenerují deklarace globálních proměnných a jejich
                inicializace na \texttt{nil}.
            \item Deklaruje se 7 interních překladačových globálních proměnných, se kterými dále pracujeme při
                vyhodnocování výrazů.
            \item Vygenerujeme kód, která zavolá funkci \texttt{main()} a po návratu ukončí program s kódem 0.
            \item Generujeme jednotlivé funkce.
        \end{enumerate}
        \subsection{Generování funkcí}
            Na začátku vygenerujeme pro funkci návěští a vytvoříme nový rámec proměnných. Název funkce je
            zapsán ve formátu \texttt{fun\$x} kde \texttt{fun} je název funkce a \texttt{x} je počet jejích
            parametrů. Následně podle lokální tabulky symbolů vygenerujeme deklarace všech lokálních proměnných.

            Dále do lokálních proměnných reprezentující parametry funkce vložíme argumenty, které se podle
            konvence volání nachází na zásobníku hodnot. Na vrcholu zásobníku vždy bude poslední argument,
            volaný je tedy popuje v obráceném pořadí.

            Pak už se generuje tělo funkce.

            Na konci se vygeneruje implicitní příkaz \texttt{return}, spolu s příkazem \texttt{POPFRAME} a
            vložením hodnoty \texttt{nil}, implicitní návratové hodnoty, na zásobník.

        \subsection{Generování příkazů}
            Pro každý možný příkaz v ASS existuje procedura, která pro tento příkaz vygeneruje cílový kód.
            \begin{itemize}
                \item \texttt{ST\_BLOCK}: Iteruje přes všechny příkazy a uvnitř bloku a generuje pro ně kód.
                \item \texttt{ST\_IF}: Vygeneruje vyhodnocení pravdivosti výrazu a podle něj skočí na správné návěští.
                \item \texttt{ST\_WHILE}: Vygeneruje vyhodnocení pravdivosti výrazu a podle něj cyklus opustí nebo v něm pokračuje. Na konci těla cyklu se skočí zpět na vyhodnocení pravdivosti.
                \item \texttt{ST\_RETURN}: Vloží na vrchol zásobníku \texttt{nil} nebo vyhodnotí vracený výraz pokud je dán. Následně vygeneruje příkazy \texttt{POPFRAME} a \texttt{RETURN}.
                \item \texttt{ST\_LOCAL\_VAR}: Pokud není dán výraz, který se má přiřadit, vloží se do proměnné \texttt{nil}. Pokud výraz dán je, vyhodnotí se a jeho hodnota se uloží do proměnné
                    z vrochu zásobníku.
                \item \texttt{ST\_GLOBAL\_VAR}: Vyhodnotí se přiřazovaný výraz a jeho hodnota se uloží do proměnné.
                \item \texttt{ST\_SETTER\_CALL}: Vyhodnotí se přiřazovaný výraz a zavolá se setter.
                \item \texttt{ST\_EXPRESSION}: Samostojící výraz se vyhodnotí a jeho hodnota se z vrcholu zásobníku zahodí.
            \end{itemize}
            \subsubsection{Optimalizace}
                Pokud přiřazujeme do proměnné výraz se známou hodnotou, místo toho, abychom ji pushnuli a následně popnuli,
                vygenerujeme rovnou instrukci \texttt{MOVE}. Například u \texttt{a = 5 + 5} se vygeneruje \texttt{MOVE LF@a?0 float@0x1.4p+3}
                namísto
                \begin{alltt}
PUSHS float@0x1.4p+3
POPS LF@a!0 \end{alltt}

                Při vyhodnocování pravdivostní hodnoty můžeme zjistit, že některé větve není potřeba generovat.
                Tuto informaci vrací funkce, které vyhodnocení pravdivosti generuje, a můžeme podle ní některé
                větve vypustit. Například u
                \begin{alltt}
if (null) \{
    ...
\} else \{
    ...
\} \end{alltt}
                není potřeba generovat větev \uv{pravda.}
        \subsection{Generování výrazů}
            Vyhodnocování výrazů probíhá na zásobníku. Nejdříve se rekurzivně vyhodnotí každý podvýraz a jejich
            hodnoty zůstanou na vrcholu zásobníku. Následně se provede jejich typová kontrola a výraz se vyhodnotí.

            Se všemi čísly se ve výsledném programu pracuje jako s \texttt{float}y. Ke konverzi na \texttt{int} dochází
            pouze v případě kde je celočíselnost potřeba, např. při operátoru iterace řetězce nebo v některých
            vestavěných funkcích.

            Jako výrazy se berou také vestavěné funkce. Tyto funkce se vyhodnocují na místě bez jakéhokoliv volání.

            Také normální funkce a gettery se berou jako výrazy a jejich vyhodnocování probíhá následovně:
            \begin{enumerate}
                \item Vyhodnotí se všechny podvýrazy reprezentující argumenty. Jejich hodnoty zůstanou na vrcholu zásobníku.
                \item Zavolá se funkce, která argumenty z vrcholu zásobníku převezme.
                \item Funkce nechá návratovou hodnotu na vrcholu zásobníku, kde si ji převezme nadvýraz.
            \end{enumerate}

            \subsubsection{Optimalizace}
                U každého výrazu mohou být ze sémantické analýzy uvedeny informace o typu výrazu a případně
                i jeho hodnota, pokud ji optimalizátor dokázal vypočítat. Pokud jsou tyto informace k dispozici,
                můžeme si někdy odpustit generování typové kontroly a někdy i samotného vyhodnocení výrazu.

                Například u \texttt{a = ("ahoj" * 2) + \_\_unknown} optimalizátor ví, že první podvýraz nabývá
                hodnoty \texttt{"ahojahoj"}, takže nic nevyhodnocujeme a jen vložíme vypočtenou hodnotu na zásobník. Při vyhodnocování
                operátoru \texttt{+} pak nemusíme kontrolovat typ levého podvýrazu, protože je ze sémantické analýzy
                jasný. Také jistě víme, že zde operátor \texttt{+} označuje konkatenaci řetězců, takže nemusíme řešit,
                že by se mohlo jednat o sčítání.
        \section{Rozdělení práce}
        \textbf{Vojtěch Borýsek}: Implementace precedenční analýzy a datových struktur.\\
        \textbf{Šimon Halas}: Implementace tabulky symbolů. Hodnocení 0\% kvůli plánovanému ukončení studia.\\
        \textbf{Tomáš Hanák}: Implementace syntaktické a sémantické analýzy a optimalizátoru.\\
        \textbf{Michal Šebesta}: Implementace lexikálního analyzátoru a generátoru kódu.

    \newpage
    \appendix
    \section{Konečný stavový automat}
    \label{app:fsm}
        \begin{figure}[ht]
            \centering
            \includegraphics{fsm.pdf}
            \caption{Diagram konečného automatu}
            \label{fig:fsm}
        \end{figure}
    \newpage
    \section{LL gramatika}
    \label{app:llgram}
        \grammar
        \newpage
    \section{LL tabulka}
    \label{app:lltable}
        \llTable
    \section{Precedenční tabulka}
    \label{app:prectable}
        \precTable
\end{document}
